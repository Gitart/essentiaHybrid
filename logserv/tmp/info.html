<!DOCTYPE html>
<html lang="en">
	<head>
	      <title>Admin</title>
	      {{template "libs"}}

			<style type="text/css">
				      h1{color:#BBCC00};
				      h2{color:#CC0022};
				      .descr-i{color:green;}
				      .descr-e{color:red;}
				      .descr-w{color:blue;}
				      .descr-f{color:lightgreen;}
				      .descr-d{color:lightblue;}
				      .descr-t{color:grey;}
			</style>
	
    </head>
<body>
    {{template "header"}}
	<br>
	<div class="container">
         <h1>Краткая информация </h1> 
         <hr>

        <h2>Сколько логировать</h2>
         <p>
            Серьезная проблема для разработчика. 
            Всегда хочется получать больше информации, но код начинает выглядеть очень плохо. 
         </p>
         
         <p>   
            Вывод в лог это по сути комментарий. Логирование уровня Trace по большей части их и заменяет.
            Уровни Trace и Debug читают разработчики, а все что выше — техподдержка и админы. 
            Поэтому до уровня Info сообщения должны точно отвечать на вопросы: «Что произошло?», «Почему?» 
            и по возможности «Как исправить?». Особенно это касается ошибок в файлах конфигурации.
         </p>   


         <h3>Краткое описание типов</h3> 
         <p>
           <b class="descr-t">Trace</b> — вывод всего подряд. На тот случай, если Debug не позволяет локализовать ошибку. В нем полезно отмечать вызовы разнообразных блокирующих и асинхронных операций.<br>
           <b class="descr-d">Debug</b> — журналирование моментов вызова «крупных» операций. Старт/остановка потока, запрос пользователя и т.п.<br>
           <b class="descr-i">Info</b> — разовые операции, которые повторяются крайне редко, но не регулярно. (загрузка конфига, плагина, запуск бэкапа)<br>
           <b class="descr-w">Warning</b> — неожиданные параметры вызова, странный формат запроса, использование дефолтных значений в замен не корректных. Вообще все, что может свидетельствовать о не штатном использовании.<br>
           <b class="descr-e">Error</b> — повод для внимания разработчиков. Тут интересно окружение конкретного места ошибки.<br>
           <b class="descr-f">Fatal</b> — тут и так понятно. Выводим все до чего дотянуться можем, так как дальше приложение работать не будет.<br>
         </p>


          <h2>Боевое развертывание</h2>
            Краткое вводное описание. <br>
            14.09.2018  


          <hr>
          <p><b>Разработка дошла до внедрения.</b></p>

          <p>	
           Отложим вопросы ротации логов, размера файлов и глубины истории. 
           Это все очень специфично для каждого проекта и настраивается в зависимости от реальной работы сервиса.
          </p>	

          <p>	
            Их следует разделить на 3 группы. 
          </p>	

			<p>	
			Группа <b>Info</b>, с соответствующим уровнем для всех источников. Это информация для администратора. 
			Здесь могут быть следующие вещи: когда приложение стартовало, правильно ли вычитаны конфиги, доступны ли требуемые сервисы, и т.д. 
			Его основное свойство: файл изменяет размер только при перезагрузке приложения. 
			В процессе работы, файл расти не должен. Это поможет обеспечить автоматизированный внешний контроль успешности запуска приложения. 

			Достаточно проверить отсутствие в файле ключевых слов <b>Error</b> и <b>Fatal</b>. 
			Проверка всегда будет занимать предсказуемо малое время.
			</p>	

			</p>				
			Группа <b>Warning</b>. Это тоже информация для администратора. Этот файл при нормальной работе должен отсутствовать или быть пустым. Соответственно мониторинг его состояния сразу укажет на сбои в работе. Гибко настроив фильтры по разным источникам, можно подобрать достаточно точный критерий, когда вообще следует обратить внимание на сервис.
			Группа Наблюдение. Как правило в ходе внедрения выделяются некоторые проблемные модули. Информация от них в детализации Debug как раз и направляется сюда.
			</p>	

           <p>Если приложение успешно внедрено, то в работе остаются только первые две группы.</p>	


           <h2>Расследование сбоев</h2>

			<p>	
			Когда работающий сервис подает признаки ошибки, то не следует его пытаться сразу перезагружать. Возможно нам «повезло» поймать ошибки связанные с неверной синхронизацией потоков. И не известно сколько в следующий раз ждать ее повторения.
			В первую очередь следует подключить заготовленные заранее конфиги для группы наблюдения. Как раз это и должен позволять делать приличный логгер. Когда мы получили подтверждение о том, что новая конфигурация успешно применена, то пытаемся опять спровоцировать сбой. Желательно несколько раз. Это обеспечит возможность для его воспроизведения в «лабораторных» условиях. Дальше уже работа программистов. А пока можно и перезагрузиться.
			</p>	

            <h2>Чего с логгером делать не следует</h2>

			<p>	
			Логгер должен быть простым и надежным как молоток. И у него должна быть четко очерчена область применения в конкретном проекте. К сожалению, разработчиков часто трудно удержать. Паттерны проектирования, это в основном полезно, но не этом случае. 

			<!-- Достаточно часто стал замечать предложения выделить для логгера обобщенный интерфейс (пример) или реализовать обертку в проекте, чтобы отложить муки выбора NLog vs log4net на потом. -->
			</p>	

			<p>	
			Что бы ни было тому причиной, надо точно помнить, что в первую очередь, такие удобства напрочь убивают компилятору возможность оптимизации. 
			</p>	

			<p>	
			Не стоит напрямую выводить информацию логгера пользователю, даже с фильтрами. Проблема в том, что эта информация зависит от внутренней структуры программы. Вряд ли вы в процессе рефакторинга пытаетесь сохранить вывод логгера. Наверное, здесь стоит просто задуматься и разделить функционал. Возможно, в проекте просто требуется еще один уровень логирования. В этом случае как раз и уместна будет обертка над логгером.
			 </p>	
	   

            <h2>Использование</h2>
	   
			<p>
				В реальной жизни, скорее всего, не понадобится настолько подробное логирование, что скорость вызова отключенного лога окажет влияние на скорость алгоритма. Сложно представить, как поведет себя сервис, если такой лог включить. Также, следует отдавать себе отчет, что речь идет о десятках наносекунд.
				</p>

				<p>
				Полезная нагрузка логируемого участка кода обычно бывает на три порядка больше вызова лога (десятки микросекунд), а операции связанные с вводом/выводом еще на три порядка (десятки миллисекунд). Таким образом критерий скорости, при выборе логгера, пока не существенен.
				</p>
     </div>							         	  	  
    {{template "footer"}}
</html>

